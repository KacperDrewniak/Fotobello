var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var Interfaces_1 = require("../Interfaces");
var makeExecutableSchema_1 = require("../makeExecutableSchema");
var typeFromAST_1 = __importDefault(require("./typeFromAST"));
var transforms_1 = require("../transforms");
var utils_1 = require("../utils");
var mergeInfo_1 = require("./mergeInfo");
function mergeSchemas(_a) {
    var _b = _a.subschemas, subschemas = _b === void 0 ? [] : _b, _c = _a.types, types = _c === void 0 ? [] : _c, typeDefs = _a.typeDefs, _d = _a.schemas, schemaLikeObjects = _d === void 0 ? [] : _d, onTypeConflict = _a.onTypeConflict, _e = _a.resolvers, resolvers = _e === void 0 ? {} : _e, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, _f = _a.mergeTypes, mergeTypes = _f === void 0 ? false : _f, mergeDirectives = _a.mergeDirectives;
    var allSchemas = [];
    var typeCandidates = {};
    var typeMap = {};
    var extensions = [];
    var directives = [];
    var schemas = __spreadArrays(subschemas);
    if (typeDefs) {
        schemas.push(typeDefs);
    }
    if (types) {
        schemas.push(types);
    }
    schemas = __spreadArrays(schemas, schemaLikeObjects);
    schemas.forEach(function (schemaLikeObject) {
        if (schemaLikeObject instanceof graphql_1.GraphQLSchema || Interfaces_1.isSubschemaConfig(schemaLikeObject)) {
            var schema_1 = transforms_1.wrapSchema(schemaLikeObject);
            allSchemas.push(schema_1);
            var operationTypes_1 = {
                Query: schema_1.getQueryType(),
                Mutation: schema_1.getMutationType(),
                Subscription: schema_1.getSubscriptionType(),
            };
            Object.keys(operationTypes_1).forEach(function (typeName) {
                if (operationTypes_1[typeName]) {
                    addTypeCandidate(typeCandidates, typeName, {
                        schema: schema_1,
                        type: operationTypes_1[typeName],
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
            if (mergeDirectives) {
                var directiveInstances = schema_1.getDirectives();
                directiveInstances.forEach(function (directive) {
                    directives.push(directive);
                });
            }
            var originalTypeMap_1 = schema_1.getTypeMap();
            Object.keys(originalTypeMap_1).forEach(function (typeName) {
                var type = originalTypeMap_1[typeName];
                if (graphql_1.isNamedType(type) &&
                    graphql_1.getNamedType(type).name.slice(0, 2) !== '__' &&
                    type !== operationTypes_1.Query &&
                    type !== operationTypes_1.Mutation &&
                    type !== operationTypes_1.Subscription) {
                    addTypeCandidate(typeCandidates, type.name, {
                        schema: schema_1,
                        type: type,
                        subschema: schemaLikeObject,
                        transformedSubschema: schema_1,
                    });
                }
            });
        }
        else if (typeof schemaLikeObject === 'string' ||
            (schemaLikeObject && schemaLikeObject.kind === graphql_1.Kind.DOCUMENT)) {
            var parsedSchemaDocument = typeof schemaLikeObject === 'string' ? graphql_1.parse(schemaLikeObject) : schemaLikeObject;
            parsedSchemaDocument.definitions.forEach(function (def) {
                var type = typeFromAST_1.default(def);
                if (type instanceof graphql_1.GraphQLDirective && mergeDirectives) {
                    directives.push(type);
                }
                else if (type && !(type instanceof graphql_1.GraphQLDirective)) {
                    addTypeCandidate(typeCandidates, type.name, {
                        type: type,
                    });
                }
            });
            var extensionsDocument = makeExecutableSchema_1.extractExtensionDefinitions(parsedSchemaDocument);
            if (extensionsDocument.definitions.length > 0) {
                extensions.push(extensionsDocument);
            }
        }
        else if (Array.isArray(schemaLikeObject)) {
            schemaLikeObject.forEach(function (type) {
                addTypeCandidate(typeCandidates, type.name, {
                    type: type,
                });
            });
        }
        else {
            throw new Error("Invalid schema passed");
        }
    });
    var mergeInfo = mergeInfo_1.createMergeInfo(allSchemas, typeCandidates, mergeTypes);
    if (typeof resolvers === 'function') {
        console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
        resolvers = resolvers(mergeInfo) || {};
    }
    else if (Array.isArray(resolvers)) {
        resolvers = resolvers.reduce(function (left, right) {
            if (typeof right === 'function') {
                console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
                right = right(mergeInfo);
            }
            return utils_1.mergeDeep(left, right);
        }, {}) || {};
        if (!resolvers) {
            resolvers = {};
        }
        else if (Array.isArray(resolvers)) {
            resolvers = resolvers.reduce(utils_1.mergeDeep, {});
        }
    }
    mergeInfo = mergeInfo_1.completeMergeInfo(mergeInfo, resolvers);
    Object.keys(typeCandidates).forEach(function (typeName) {
        if ((typeName === 'Query' ||
            typeName === 'Mutation' ||
            typeName === 'Subscription' ||
            (mergeTypes === true && !(typeCandidates[typeName][0].type instanceof graphql_1.GraphQLScalarType)) ||
            (typeof mergeTypes === 'function') && mergeTypes(typeName, typeCandidates[typeName]) ||
            Array.isArray(mergeTypes) && mergeTypes.includes(typeName) ||
            mergeInfo.mergedTypes[typeName])) {
            typeMap[typeName] = merge(typeName, typeCandidates[typeName]);
        }
        else {
            var candidateSelector = onTypeConflict ?
                onTypeConflictToCandidateSelector(onTypeConflict) :
                function (cands) { return cands[cands.length - 1]; };
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    });
    utils_1.healTypes(typeMap, directives, { skipPruning: true });
    var mergedSchema = new graphql_1.GraphQLSchema({
        query: typeMap.Query,
        mutation: typeMap.Mutation,
        subscription: typeMap.Subscription,
        types: Object.keys(typeMap).map(function (key) { return typeMap[key]; }),
        directives: directives.length ?
            directives.map(function (directive) { return utils_1.cloneDirective(directive); }) :
            undefined
    });
    extensions.forEach(function (extension) {
        mergedSchema = graphql_1.extendSchema(mergedSchema, extension, {
            commentDescriptions: true,
        });
    });
    makeExecutableSchema_1.addResolversToSchema({
        schema: mergedSchema,
        resolvers: resolvers,
        inheritResolversFromInterfaces: inheritResolversFromInterfaces
    });
    utils_1.forEachField(mergedSchema, function (field) {
        if (field.resolve) {
            var fieldResolver_1 = field.resolve;
            field.resolve = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_1(parent, args, context, newInfo);
            };
        }
        if (field.subscribe) {
            var fieldResolver_2 = field.subscribe;
            field.subscribe = function (parent, args, context, info) {
                var newInfo = __assign(__assign({}, info), { mergeInfo: mergeInfo });
                return fieldResolver_2(parent, args, context, newInfo);
            };
        }
    });
    if (schemaDirectives) {
        utils_1.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
    }
    utils_1.healSchema(mergedSchema);
    return mergedSchema;
}
exports.default = mergeSchemas;
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!typeCandidates[name]) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return function (cands) {
        return cands.reduce(function (prev, next) {
            var type = onTypeConflict(prev.type, next.type, {
                left: {
                    schema: prev.schema,
                },
                right: {
                    schema: next.schema,
                },
            });
            if (prev.type === type) {
                return prev;
            }
            else if (next.type === type) {
                return next;
            }
            else {
                return {
                    schemaName: 'unknown',
                    type: type
                };
            }
        });
    };
}
function merge(typeName, candidates) {
    var initialCandidateType = candidates[0].type;
    if (candidates.some(function (candidate) { return candidate.type.constructor !== initialCandidateType.constructor; })) {
        throw new Error("Cannot merge different type categories into common type " + typeName + ".");
    }
    if (initialCandidateType instanceof graphql_1.GraphQLObjectType) {
        return new graphql_1.GraphQLObjectType({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), candidate.type.toConfig().fields)); }, {}),
            interfaces: candidates.reduce(function (acc, candidate) {
                var interfaces = candidate.type.toConfig().interfaces;
                return interfaces ? acc.concat(interfaces) : acc;
            }, []),
        });
    }
    else if (initialCandidateType instanceof graphql_1.GraphQLInterfaceType) {
        return new graphql_1.GraphQLInterfaceType({
            name: typeName,
            fields: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), candidate.type.toConfig().fields)); }, {}),
        });
    }
    else if (initialCandidateType instanceof graphql_1.GraphQLUnionType) {
        return new graphql_1.GraphQLUnionType({
            name: typeName,
            types: candidates.reduce(function (acc, candidate) { return candidate.type.toConfig().types; }, []),
        });
    }
    else if (initialCandidateType instanceof graphql_1.GraphQLEnumType) {
        return new graphql_1.GraphQLEnumType({
            name: typeName,
            values: candidates.reduce(function (acc, candidate) { return (__assign(__assign({}, acc), candidate.type.toConfig().values)); }, {}),
        });
    }
    else if (initialCandidateType instanceof graphql_1.GraphQLScalarType) {
        throw new Error("Cannot merge type " + typeName + ". Merging not supported for GraphQLScalarType.");
    }
    else {
        // not reachable.
        throw new Error("Type " + typeName + " has unknown GraphQL type.");
    }
}
//# sourceMappingURL=mergeSchemas.js.map