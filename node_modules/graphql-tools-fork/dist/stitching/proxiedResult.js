var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var checkResultAndHandleErrors_1 = require("./checkResultAndHandleErrors");
var errors_1 = require("./errors");
var utils_1 = require("../utils");
if ((typeof global !== 'undefined' && 'Symbol' in global) ||
    (typeof window !== 'undefined' && 'Symbol' in window)) {
    exports.OBJECT_SUBSCHEMA_SYMBOL = Symbol('initialSubschema');
    exports.FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol('subschemaMap');
    exports.ERROR_SYMBOL = Symbol('subschemaErrors');
}
else {
    exports.OBJECT_SUBSCHEMA_SYMBOL = Symbol('@@__initialSubschema');
    exports.FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol('@@__subschemaMap');
    exports.ERROR_SYMBOL = '@@__subschemaErrors';
}
function isProxiedResult(result) {
    return result && result[exports.ERROR_SYMBOL];
}
exports.isProxiedResult = isProxiedResult;
function getSubschema(result, responseKey) {
    var subschema = result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL] && result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];
    return subschema ? subschema : result[exports.OBJECT_SUBSCHEMA_SYMBOL];
}
exports.getSubschema = getSubschema;
function setObjectSubschema(result, subschema) {
    result[exports.OBJECT_SUBSCHEMA_SYMBOL] = subschema;
}
exports.setObjectSubschema = setObjectSubschema;
function setErrors(result, errors) {
    result[exports.ERROR_SYMBOL] = errors;
}
exports.setErrors = setErrors;
function getErrors(result, pathSegment) {
    var errors = result && result[exports.ERROR_SYMBOL];
    if (!Array.isArray(errors)) {
        return null;
    }
    var fieldErrors = [];
    for (var _i = 0, errors_2 = errors; _i < errors_2.length; _i++) {
        var error = errors_2[_i];
        if (!error.path || error.path[0] === pathSegment) {
            fieldErrors.push(error);
        }
    }
    return fieldErrors;
}
exports.getErrors = getErrors;
function unwrapResult(parent, info, path) {
    var pathLength = path.length;
    for (var i = 0; i < pathLength; i++) {
        var responseKey = path[i];
        var errors = getErrors(parent, responseKey);
        var subschema = getSubschema(parent, responseKey);
        var object = parent[responseKey];
        if (object == null) {
            return checkResultAndHandleErrors_1.handleNull(info.fieldNodes, graphql_1.responsePathAsArray(info.path), errors);
        }
        setErrors(object, errors.map(function (error) {
            return errors_1.relocatedError(error, error.nodes, error.path ? error.path.slice(1) : undefined);
        }));
        setObjectSubschema(object, subschema);
        parent = object;
    }
    return parent;
}
exports.unwrapResult = unwrapResult;
function dehoistResult(parent, delimeter) {
    if (delimeter === void 0) { delimeter = '__gqltf__'; }
    var result = Object.create(null);
    Object.keys(parent).forEach(function (alias) {
        var obj = result;
        var fieldNames = alias.split(delimeter);
        var fieldName = fieldNames.pop();
        fieldNames.forEach(function (key) {
            obj = obj[key] = obj[key] || Object.create(null);
        });
        obj[fieldName] = parent[alias];
    });
    result[exports.ERROR_SYMBOL] = parent[exports.ERROR_SYMBOL].map(function (error) {
        if (error.path) {
            var path = error.path.slice();
            var pathSegment = path.shift();
            var expandedPathSegment = pathSegment.split(delimeter);
            return errors_1.relocatedError(error, error.nodes, expandedPathSegment.concat(path));
        }
        else {
            return error;
        }
    });
    result[exports.OBJECT_SUBSCHEMA_SYMBOL] = parent[exports.OBJECT_SUBSCHEMA_SYMBOL];
    return result;
}
exports.dehoistResult = dehoistResult;
function mergeProxiedResults(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var errors = target[exports.ERROR_SYMBOL].concat(sources.map(function (source) { return source[exports.ERROR_SYMBOL]; }));
    var fieldSubschemaMap = sources.reduce(function (acc, source) {
        var subschema = source[exports.OBJECT_SUBSCHEMA_SYMBOL];
        Object.keys(source).forEach(function (key) {
            acc[key] = subschema;
        });
        return acc;
    }, {});
    var result = utils_1.mergeDeep.apply(void 0, __spreadArrays([target], sources));
    result[exports.ERROR_SYMBOL] = errors;
    result[exports.FIELD_SUBSCHEMA_MAP_SYMBOL] = target[exports.FIELD_SUBSCHEMA_MAP_SYMBOL] ?
        utils_1.mergeDeep(target[exports.FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap) :
        fieldSubschemaMap;
    return result;
}
exports.mergeProxiedResults = mergeProxiedResults;
//# sourceMappingURL=proxiedResult.js.map